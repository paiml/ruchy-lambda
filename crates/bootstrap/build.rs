// build.rs - Automated Ruchy â†’ Rust transpilation
// Integrates Ruchy transpiler into Cargo build process
//
// This runs during `cargo build` BEFORE compiling Rust code
// Automatically transpiles .ruchy files to .rs files

use std::path::{Path, PathBuf};
use std::process::Command;

fn main() {
    println!("cargo:rerun-if-changed=src/handler.ruchy");
    println!("cargo:rerun-if-changed=../../examples/simple_handler.ruchy");

    // Path to Ruchy compiler (use trunk version)
    let ruchy_path = "../../../ruchy/target/debug/ruchy";

    // Check if ruchy exists, if not try cargo run
    let ruchy_exists = Path::new(ruchy_path).exists();

    if !ruchy_exists {
        println!("cargo:warning=Building Ruchy transpiler first...");
        // Build ruchy if not built
        let status = Command::new("cargo")
            .args(["build", "--manifest-path", "../../../ruchy/Cargo.toml"])
            .status()
            .expect("Failed to build Ruchy");

        if !status.success() {
            panic!("Failed to build Ruchy transpiler");
        }
    }

    // Transpile example handler if it exists
    let example_input = PathBuf::from("../../examples/simple_handler.ruchy");
    let example_output = PathBuf::from("../../examples/simple_handler_generated.rs");

    if example_input.exists() {
        println!("cargo:warning=Transpiling simple_handler.ruchy...");
        transpile_file(&example_input, &example_output, ruchy_path);
    }

    // Transpile main handler if it exists
    let handler_input = PathBuf::from("src/handler.ruchy");
    let handler_output = PathBuf::from("src/handler_generated.rs");

    if handler_input.exists() {
        println!("cargo:warning=Transpiling src/handler.ruchy...");
        transpile_file(&handler_input, &handler_output, ruchy_path);
    }

    // Transpile minimal handler if it exists (for lambda-perf benchmarks)
    let handler_minimal_input = PathBuf::from("src/handler_minimal.ruchy");
    let handler_minimal_output = PathBuf::from("src/handler_minimal_generated.rs");

    if handler_minimal_input.exists() {
        println!("cargo:warning=Transpiling src/handler_minimal.ruchy...");
        transpile_file(&handler_minimal_input, &handler_minimal_output, ruchy_path);
        println!("cargo:rerun-if-changed=src/handler_minimal.ruchy");
    }

    // Transpile fibonacci handler if it exists (for CPU benchmarks)
    let handler_fibonacci_input = PathBuf::from("src/handler_fibonacci.ruchy");
    let handler_fibonacci_output = PathBuf::from("src/handler_fibonacci_generated.rs");

    if handler_fibonacci_input.exists() {
        println!("cargo:warning=Transpiling src/handler_fibonacci.ruchy...");
        transpile_file(
            &handler_fibonacci_input,
            &handler_fibonacci_output,
            ruchy_path,
        );
        println!("cargo:rerun-if-changed=src/handler_fibonacci.ruchy");
    }

    println!("cargo:warning=Ruchy transpilation complete");
}

fn transpile_file(input: &Path, output: &Path, ruchy_path: &str) {
    let status = Command::new(ruchy_path)
        .args(["transpile", input.to_str().unwrap()])
        .output()
        .expect("Failed to run Ruchy transpiler");

    if !status.status.success() {
        let stderr = String::from_utf8_lossy(&status.stderr);
        panic!("Ruchy transpilation failed for {:?}: {}", input, stderr);
    }

    // Write transpiled output with dead code allowance for generated stubs
    let mut transpiled = String::from_utf8_lossy(&status.stdout).to_string();

    // Add clippy suppression to public functions (generated code)
    transpiled = transpiled.replace("pub fn ", "#[allow(clippy::all)]\npub fn ");

    // Add #[allow(dead_code)] to empty main() functions generated by Ruchy
    if transpiled.contains("fn main() {}") {
        transpiled = transpiled.replace("fn main() {}", "#[allow(dead_code)]\nfn main() {}");
    }

    std::fs::write(output, transpiled.as_bytes()).expect("Failed to write transpiled output");

    println!("cargo:warning=  âœ… Transpiled {:?} -> {:?}", input, output);
}
