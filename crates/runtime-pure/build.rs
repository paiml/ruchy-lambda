// build.rs - Transpile Ruchy runtime to Rust at build time
//
// Pure Ruchy Runtime: All implementation in .ruchy files
// Transpiles to *_generated.rs during build
//
// Follows proven pattern from crates/bootstrap/build.rs

use std::env;
use std::path::Path;
use std::process::Command;

fn main() {
    println!("cargo:rerun-if-changed=src/lib.ruchy");
    println!("cargo:rerun-if-changed=src/http_client.ruchy");
    println!("cargo:rerun-if-changed=src/event.ruchy");
    println!("cargo:rerun-if-changed=src/logger.ruchy");

    println!("cargo:warning=ğŸ”„ Transpiling Pure Ruchy Runtime...");

    // Transpile core runtime modules
    transpile_ruchy_file("src/lib.ruchy", "src/lib_generated.rs");

    println!("cargo:warning=âœ… Pure Ruchy Runtime transpilation complete");
}

/// Transpile a single .ruchy file to Rust
fn transpile_ruchy_file(input: &str, output: &str) {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let input_path = Path::new(&manifest_dir).join(input);
    let output_path = Path::new(&manifest_dir).join(output);

    // Check if input file exists
    if !input_path.exists() {
        println!("cargo:warning=â­ï¸  Skipping {input} (file not found)");
        return;
    }

    // Run Ruchy transpiler (outputs to stdout)
    println!("cargo:warning=  Transpiling {input}...");

    let status = Command::new("ruchy")
        .arg("transpile")
        .arg(&input_path)
        .output()
        .expect("Failed to run ruchy transpiler");

    if !status.status.success() {
        let stderr = String::from_utf8_lossy(&status.stderr);
        panic!("Ruchy transpilation failed for {input}: {stderr}");
    }

    // Get transpiled code from stdout
    let mut transpiled = String::from_utf8_lossy(&status.stdout).to_string();

    // Post-process generated code for library usage

    // Remove stub modules generated by Ruchy transpiler (we want real std::net)
    // Find and remove "mod net {" ... "}" block
    if let Some(net_start) = transpiled.find("mod net {") {
        if let Some(net_end) = transpiled[net_start..].find("}\nmod http") {
            transpiled.replace_range(net_start..(net_start + net_end + 1), "");
        }
    }

    // Remove "mod http {" ... "}" block
    if let Some(http_start) = transpiled.find("mod http {") {
        // Find matching closing brace - scan for "}\nuse std::" or "}\n#[derive"
        let after_http = &transpiled[http_start..];
        if let Some(http_end) = after_http.find("}\nuse std::") {
            transpiled.replace_range(http_start..(http_start + http_end + 1), "");
        } else if let Some(http_end) = after_http.find("}\n#[derive") {
            transpiled.replace_range(http_start..(http_start + http_end + 1), "");
        }
    }

    // Read http_client.rs and inject it as a module
    let http_client_path = Path::new(&manifest_dir).join("src/http_client.rs");
    let http_client_code = if http_client_path.exists() {
        std::fs::read_to_string(&http_client_path).expect("Failed to read http_client.rs")
    } else {
        String::from("// http_client.rs not found")
    };

    // Wrap http_client code in a module
    let http_client_module = format!("mod http_client {{\n{}\n}}\n\n", http_client_code);
    transpiled = format!("{}{}", http_client_module, transpiled);

    // Fix module path separator: http_client.method() -> http_client::method()
    transpiled = transpiled.replace("http_client.http_get(", "http_client::http_get(");
    transpiled = transpiled.replace("http_client\n                        .http_post(", "http_client::http_post(");

    // Fix method signatures: `self` -> `&self` for borrowing
    transpiled = transpiled.replace("fn next_event(self)", "fn next_event(&self)");
    transpiled = transpiled.replace("fn post_response(self,", "fn post_response(&self,");
    transpiled = transpiled.replace("fn http_get(self,", "fn http_get(&self,");
    transpiled = transpiled.replace("fn http_post(self,", "fn http_post(&self,");
    transpiled = transpiled.replace("fn parse_response(self,", "fn parse_response(&self,");
    transpiled = transpiled.replace("fn endpoint(self)", "fn endpoint(&self)");

    // Make methods public
    transpiled = transpiled.replace("fn new()", "pub fn new()");
    transpiled = transpiled.replace("fn next_event(", "pub fn next_event(");
    transpiled = transpiled.replace("fn post_response(", "pub fn post_response(");
    transpiled = transpiled.replace("fn endpoint(", "pub fn endpoint(");

    // Remove main() function (not needed for library)
    transpiled = transpiled.replace("fn main() {}", "");

    // Add clippy suppression for generated code
    transpiled = format!("#![allow(clippy::all)]\n\n{}", transpiled);

    std::fs::write(&output_path, transpiled.as_bytes()).expect("Failed to write transpiled output");

    println!("cargo:warning=    âœ… Transpiled {input} -> {output}");
}
