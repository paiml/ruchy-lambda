// Generated by Ruchy Transpiler
// Source: examples/hello_world.ruchy
//
// This is the EXPECTED Rust output that the transpiler should generate
// Used for validation and testing

use ruchy_lambda_runtime::{LambdaEvent, Runtime};
use serde_json::{json, Value};
use std::error::Error;

/// Lambda handler function
/// Transpiled from Ruchy: def handler(event)
fn handler(event: LambdaEvent) -> Result<Value, Box<dyn Error>> {
    // Extract request context
    // Transpiled from: request_id = event["requestContext"]["requestId"]
    let request_id = &event.request_context.request_id;

    // Simple string interpolation
    // Transpiled from: message = "Hello from Ruchy Lambda! Request ID: #{request_id}"
    let message = format!("Hello from Ruchy Lambda! Request ID: {}", request_id);

    // Return Lambda response
    // Transpiled from: { "statusCode" => 200, "body" => message }
    Ok(json!({
        "statusCode": 200,
        "body": message
    }))
}

/// Entry point for Lambda runtime
/// Transpiled from: Lambda.start(handler: :handler)
#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    // Initialize Ruchy Lambda Runtime
    let runtime = Runtime::new()?;

    // Event processing loop
    loop {
        // Get next event from Lambda Runtime API
        let event_json = runtime.next_event().await?;

        // Deserialize event
        let event: LambdaEvent = serde_json::from_str(&event_json)?;

        // Extract request ID for response
        let request_id = event.request_context.request_id.clone();

        // Invoke handler
        let response = handler(event)?;

        // Serialize response
        let response_json = serde_json::to_string(&response)?;

        // Post response to Lambda Runtime API
        runtime.post_response(&request_id, &response_json).await?;
    }
}
